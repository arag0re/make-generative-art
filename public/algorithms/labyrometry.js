seed = tokenData.hash

HW = Math.min(window.innerWidth, window.innerHeight), BOO = seed.split("").map(r => parseInt(Number("0x" + r), 10) % 2), S = Uint32Array.from([0, 1, s = t = 2, 3].map(r => parseInt(seed.substr(8 * r + 2, 8), 16))), R = (r => (t = S[3], S[3] = S[2], S[2] = S[1], S[1] = s = S[0], t ^= t << 11, S[0] ^= t ^ t >>> 8 ^ s >>> 19, S[0] / 2 ** 32)), ptt = { citrus: ["#fabc3c", "#f19143", "#ffb238", "#f55536", "#820933", "#d84797", "#ff773d", "#d2fdff", "#3abeff", "#26ffe6"], pastel: ["#cae7b9", "#eb9486", "#7e7f9a", "#97a7b3", "#f3de8a", "#8cb369", "#f4e285", "#f4a259", "#5b8e7d", "#bc4b51"], soup: ["#483c46", "#3c6e71", "#70ae6e", "#f4743b", "#ffaf87", "#ff8e72", "#ed6a5e", "#beee62", "#4ce0b3", "#377771"], brights: ["#00ff3c", "#f700ff", "#f6ff00", "#00ff3c", "#f700ff", "#f6ff00", "#00ff3c", "#f700ff"], flushed: ["#ff3700", "#f6ff00", "#1eff00", "#00ffae", "#0062ff", "#a200ff", "#ffffff", "#ff00aa"], solids: ["#70a7ff", "#ff7070", "#fff170", "#75ff70", "#0062ff", "#7570ff", "#ee70ff", "#ff707a"], blackwhite: ["#000000", "#ffffff", "#000000", "#ffffff", "#000000", "#ffffff", "#000000", "#ffffff", "#000000", "#ffffff"] }, p5.prototype.square = function (r, f, e, t, s, o, W) { return p5._validateParameters("square", arguments), this._renderRect.apply(this, [r, f, e, e, t, s, o, W]) }; var bru, sqO, bgs, scrt = "", flg = 0, cYc = Math.floor(3 * R()) + 2; function setup() { for (frameRate(60), createCanvas(HW, HW), bru = ptt[Object.keys(ptt)[int(Object.keys(ptt).length * R())]], background(bru[0]), noFill(), bgs = ["bgT"], BOO[2] && bgs.push("bgO"), BOO[3] && bgs.push("bgTw"), i = 1; i < 10; i++)window[bgs[int(bgs.length * R())]](); largeOffset = HW / 5, smallOffset = HW / int(10 * R() + 10 * R()), BOO[20] && BOO[29] ? (sqO = largeOffset, strokeJoin(ROUND)) : BOO[21] ? (sqO = smallOffset, strokeJoin(ROUND)) : sqO = 0 } function draw() { frameCount % cYc == 0 && noLoop(), window[bgs[int(bgs.length * R())]](), objOne(), frameCount % cYc != 0 && (objTwo(), BOO[33] && BOO[35] && objTwo(), BOO[33] && BOO[34] && objTwo()), BOO[13] ? (strokeWeight(HW / 10), stroke(bru[0]), square(0, 0, HW)) : (stroke(color("black")), strokeWeight(HW / 250), square(HW / 20 + HW / 250, HW / 20 + HW / 250, HW - HW / 10 + HW / 250, (BOO[13] ? 0 : sqO) + HW / 250)), stroke(bru[1]), strokeWeight(HW / 250), square(HW / 20, HW / 20, HW - HW / 10, BOO[13] ? 0 : sqO) } function objOne() { push(), c = color(bru[3]), c.setAlpha(255 * R()), stroke(c), sw = HW / 20 * R(), strokeWeight(sw), noFill(), r1 = HW * R(), r2 = HW * R(), r3 = HW * R(), r7 = HW / 4 * R(), r8 = HW / 5 * R(), r9 = HW * R(), BOO[11] && (push(), stroke(color("black")), square(r1 + HW / 200, r2 + HW / 200, r3, sqO), pop(), square(r1, r2, r3, sqO)), push(), stroke(color("black")), square(r7 + HW / 200, r8 + HW / 200, r9, sqO), pop(), square(r7, r8, r9, sqO), BOO[32] && BOO[33] && BOO[10] ? (push(), stroke(color("white")), strokeWeight(HW / 250), square(r7, r8, r9, sqO), pop()) : BOO[34] && BOO[10] && (push(), stroke(bru[int(R() * bru.length)]), strokeWeight(HW / 250), square(r7, r8, r9, sqO), pop()), pop() } function objTwo() { push(), strokeCap(SQUARE), c = color(bru[5]), c.setAlpha(255 * R()), stroke(c), strokeWeight(HW / 20 * R()), 1 == frameCount && BOO[27] ? fill(color("black")) : fill(color(bru[int(bru.length * R())])), x = HW * R(), y = HW * R(), r1 = HW * R(), r2 = HW * R(), r3 = HW * R(), r4 = HW * R(), push(), stroke(color("black")), triangle(r1 + HW / 200, r2 + HW / 200, x + HW / 200, y + HW / 200, r3 + HW / 200, r4 + HW / 200), pop(), triangle(r1, r2, x, y, r3, r4), stroke(bru[int(R() * bru.length)]), strokeWeight(HW / 250), triangle(r1 + HW / 200, r2 + HW / 200, x + HW / 200, y + HW / 200, r3 + HW / 200, r4 + HW / 200), pop() } function bgO() { for (x = 0; x <= HW; x += int(HW / 10))for (y = 0; y <= HW; y += int(HW / 10))strokeWeight(HW / (100 * R() + 20)), bsa(), bezier(x * R(), y * R(), 2 * x, 2 * y, HW, HW * R(), x / 2 * R(), y / 2 * R()), bsa(), circle(HW * R(), HW * R(), HW / 2 * R()) } function bgTw() { for (x = 0; x <= HW; x += int(HW / 10))for (y = 0; y <= HW; y += int(HW / 10))strokeWeight(HW / (100 * R() + 20)), bsa(), triangle(x / 2 * R(), y * R(), 2 * x * R(), 2 * y * R(), x / 2 * R(), y / 2 * R()) } function bgT() { for (x = 0; x <= HW; x += int(HW / 10))for (y = 0; y <= HW; y += int(HW / 10))strokeWeight(HW / (100 * R() + 20)), bsa(), bezier(x * R(), y * R(), 2 * x, 2 * y, HW, HW * R(), x / 2 * R(), y / 2 * R()), bsa(), bezier(0, 0, 2 * x, 2 * y, HW * R(), HW * R(), x / 2 * R(), y / 2 * R()) } function bgSA() { return rca = 30, BOO[18] && BOO[20] && BOO[27] && (rca = 10 * R()), function () { c = color(bru[int(bru.length * R())]), c.setAlpha(rca), stroke(c) } } function keyTyped() { scrt += key, "s" === key && saveCanvas("o", "png"), scrt.endsWith("abrulez") && (flg = 1), 1 == flg && "s" != key && (bru = "b" === key ? ptt.blackwhite : ptt[Object.keys(ptt)[int(Object.keys(ptt).length * R())]], loop()) } bsa = bgSA();