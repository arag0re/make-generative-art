let ov, ma, im, cP, nC, bag, oC, hPa = [], hDa = [], s = parseInt(tokenData.hash.slice(0, 16), 16), cn = 0, dim = 0, cl = [[]], dC = 0, iR = !1, iL = !1, iVB = !1, pI = 0, pH = 0, cPI = 0, aL = [], li = -1, oCt = 0; function setup() { dim = Math.floor(Math.min(window.innerWidth, window.innerHeight)), createCanvas(dim, dim), noLoop(); for (let c = 0; c < 32; c++)hPa.push(tokenData.hash.slice(2 + 2 * c, 4 + 2 * c)); hDa = hPa.map(c => parseInt(c, 16)), cn = dim / 2, ov = createGraphics(dim, dim), ma = createGraphics(dim, dim), im = createImage(dim, dim), pH = rnd() < .2 ? .9 : .4, dC = hDa[0] < 21 ? 11 : hDa[0] < 41 ? 121 : hDa[0] < 72 ? 31 : hDa[0] < 122 ? 61 : 91, cl[0][0] = c(150), cl[0][1] = c(125), cl[0][2] = c(100), cl[0][3] = c(65), cl[0][4] = c(30), cl.push([]), cl[1][0] = c("#164849"), cl[1][1] = c("#02aca3"), cl[1][2] = c("#2a2833"), cl[1][3] = c("#970126"), cl[1][4] = c("#cbd5ee"), cl[1][5] = c("#eb8b01"), cl[1][6] = c("#eee00b"), cl[1][7] = c("#012c9f"), cl.push([]), cl[2][0] = c("#899194"), cl[2][1] = c("#e5d503"), cl[2][2] = c("#2b7260"), cl[2][3] = c("#0c1885"), cl[2][4] = c("#5d71b3"), cl[2][5] = c("#141717"), cl[2][6] = c("#9f2317"), cl.push([]), cl[3][0] = c("#efe5a7"), cl[3][1] = c("#002972"), cl[3][2] = c("#f7e038"), cl[3][3] = c("#852129"), cl[3][4] = c("#2e2721"), cl.push([]), cl[4][0] = c("#f2d83d"), cl[4][1] = c("#e52d21"), cl[4][2] = c("#3f3083"), cl.push([]), cl[5][0] = c("#d75b66"), cl[5][1] = c("#23345c"), cl[5][2] = c("#fc1"), cl[5][3] = c("#a36142"), cl[5][4] = c("#54493f"), cl.push([]), cl[6][0] = c("#1f3330"), cl[6][1] = c("#212027"), cl[6][2] = c("#f22f08"), cl[6][3] = c("#ff6f3f"), cl[6][4] = c("#b23136"), cl.push([]), cl[7][0] = c("#2e7daf"), cl[7][1] = c("#ffd507"), cl[7][2] = c("#2897ff"), cl[7][3] = c("#ff665b"), cl[7][4] = c("#66395d"), cl.push([]), cl[8][0] = c("#0444bf"), cl[8][1] = c("#0584f2"), cl[8][2] = c("#0aaff1"), cl[8][3] = c("#e3ef3b"), cl[8][4] = c("#ae5cb2"), cl.push([]), cl[9][0] = c("#6465a5"), cl[9][1] = c("#6975a6"), cl[9][2] = c("#f2e44b"), cl[9][3] = c("#ff4d35"), cl[9][4] = c("#f05837"), cl.push([]), cl[10][0] = c("#f4ed71"), cl[10][1] = c("#9e2504"), cl[10][2] = c("#767287"), cl[10][3] = c("#04030c"), cl[10][4] = c("#383140"), cl.push([]), cl[11][0] = c("#192e5b"), cl[11][1] = c("#2c42a5"), cl[11][2] = c("#4d52bc"), cl[11][3] = c("#00743f"), cl[11][4] = c("#efb700"), cl.push([]), cl[12][0] = c("#6F706F"), cl[12][1] = c("#65A547"), cl[12][2] = c("#f4ba18"), cl[12][3] = c("#f4650c"), cl[12][4] = c("#8b281f"), cl.push([]), cl[13][0] = c("#a3586d"), cl[13][1] = c("#5c4a72"), cl[13][2] = c("#f2be46"), cl[13][3] = c("#ef4e26"), cl[13][4] = c("#f25252"), cl.push([]), cl[14][0] = c("#2b87d8"), cl[14][1] = c("#0abda0"), cl[14][2] = c("#2ef487"), cl[14][3] = c("#d4e83c"), cl[14][4] = c("#c64837"), cl.push([]), cl[15][0] = c("#040627"), cl[15][1] = c("#03353e"), cl[15][2] = c("#0294a5"), cl[15][3] = c("#374351"), cl[15][4] = c("#c1403d"), cl.push([]), cl[16][0] = c("#55d9c0"), cl[16][1] = c("#ff60d2"), cl[16][2] = c("#107050"), cl[16][3] = c("#02231c"), cl[16][4] = c("#4dd8ad"), cl.push([]), cl[17][0] = c("#f55"), cl[17][1] = c("#29e"), cl[17][2] = c("#f24"), cl[17][3] = c("#70f"), cl[17][4] = c("#99d"), cl[17][5] = c("#3ac"), cl.push([]), cl[18][0] = c("#f01"), cl[18][1] = c("#16f"), cl[18][2] = c("#f11"), cl[18][3] = c("#75f"), cl[18][4] = c("#f67"), cl[18][5] = c("#fd1"), cPI = hDa[1] < 7 ? 0 : int(map(hDa[1], 7, 256, 1, cl.length)), cP = cl[cPI], bag = hDa[2] < 64 ? c(0) : c(255), iVB = hDa[2] > 128, pI = hDa[3] < 24 ? .7 : hDa[3] < 152 ? .15 : .4; let l = tokenData.hash.toLowerCase(); iR = l.indexOf("52") >= 0 && l.indexOf("4f") >= 0 && l.indexOf("59") >= 0, aL.push({ id: 76, ltr: "L" }), aL.push({ id: 149, ltr: "I" }), aL.push({ id: 216, ltr: "C" }), aL.push({ id: 288, ltr: "H" }), aL.push({ id: 372, ltr: "T" }), aL.push({ id: 441, ltr: "E" }), aL.push({ id: 519, ltr: "N" }), aL.push({ id: 602, ltr: "S" }), aL.push({ id: 686, ltr: "T" }), aL.push({ id: 755, ltr: "E" }), aL.push({ id: 828, ltr: "I" }), aL.push({ id: 906, ltr: "N" }); let e = tokenData.tokenId % 1e6; for (let c = 0; c < aL.length; c++)aL[c].id - 1 === e && (iL = !0, li = c) } function draw() { background(255), push(), translate(cn, cn), pS(), pop(), ov.remove(), ma.remove() } function pS() { sL(), iL ? sLi() : iR && sR() } function vB() { iVB && (bag = rnd() < .5 ? c(0) : c(255)) } function nCl() { return cP[int(map(rnd(), 0, 1, 0, cP.length))] } function oP() { (im = ov.get()).mask(ma), image(im, -cn, -cn) } function sR() { oC = 9; for (let c = 0; c < oC; c++) { nC = nCl(), vB(); let l = pPN(); ov = pP(l, nC, bag, !1, !0, !0), ma = mR(ma, c), oP() } } function sLi() { nC = nCl(), vB(); let c = pPN(); ov = pP(c, nC, bag, !1, !0, !0), ma = mLi(ma), oP() } function sL() { let c, l; oC = hDa[4] < 11 ? 2 : int(map(hDa[4], 11, 256, 3, 13)); let e = dim / 1e3, t = 0, a = 0, n = [], i = new Array(oC + 1); i[0] = new Array(1e3); let o = 0; iR || iL || (hDa[5] < 75 ? (rotate(PI / 2), o = 1) : hDa[5] < 150 ? (rotate(3 * PI / 2), o = 3) : hDa[5] < 205 && (rotate(PI), o = 2)); for (let c = 0; c <= dim; c += e)i[0][t] = 0, t++; noiseSeed(map(rnd(), 0, 1, 0, 1e3)); let r = hDa[6] < 11 ? .008 : hDa[6] < 26 ? .005 : .002; for (let d = 0; d < oC; d++) { let f = map(rnd(), 0, 1, 0, 1e3); n.push({ h: a }); let h = map(rnd(), 0, 1, .1 * (dim - a), (dim - a) / map(oC, 2, 16, 1.2, 2.5)); t = 0, i[d + 1] = new Array(1e3); for (let c = 0; c <= dim; c += e)d === oC - 1 ? i[d + 1][t] = dim : (i[d + 1][t] = n[d].h + map(noise(f), 0, 1, 0, h), f += r), i[d + 1][t] > a && (a = i[d + 1][t]), t++; nC = nCl(), vB(); let s = pPN(); nC === c && s === l && (nC = lerpColor(nC, bag, .4)), c = nC, l = s, ov = pP(s, nC, bag, o, !iR && !iL, !1), ma = mPC(ma, i[d], i[d + 1], e), oP() } } function pPN() { return hDa[6 + ++oCt] < 66 ? 0 : hDa[6 + oCt] < 140 ? 1 : hDa[6 + oCt] < 176 ? 2 : 3 } function pP(c, l, e, t, a, n) { if (0 === c) ov = pSo(ov, l); else { if (a && (rnd() < pI || n)) { let c = l; l = e, e = c } 1 === c ? ov = pSt(ov, l, e, t) : 2 === c ? ov = pDo(ov, l, e, dC, !0) : 3 === c && (ov = pDo(ov, l, e, dC, !1)) } return ov } function pDo(c, l, e, t, a) { t % 2 == 0 && (t += 1); let n = dim / (1.25 * t), i = t + 1, o = dim / t, r = o / 2, d = -r - cn, f = -r - cn, h = 0, s = n / t * pH, p = n; c.clear(), c.background(e), c.noStroke(), c.fill(l), c.push(), c.translate(cn, cn); let m = rnd() < .5; a && m && c.rotate(PI); for (let l = 1; l <= i; l++)for (let e = 1; e <= t; e++)h = e % 2 == 0 ? r : 0, a && (p = n - (l - 1) * s), c.ellipse(l * o + d - h, e * o + f, p, p); return c.pop(), c } function pSo(c, l) { return c.clear(), c.background(l), c.noStroke(), c.fill(l), c } function pSt(c, l, e, t) { let a = 100, n = dim / a; a *= 3, c.clear(), c.background(l), c.noFill(), c.stroke(e), c.strokeWeight(n), c.push(), c.translate(cn, cn), c.rotate(PI / 6), 1 === t ? c.rotate(-PI / 2) : 2 === t ? c.rotate(-PI) : 3 === t && c.rotate(-3 * PI / 2); for (let l = 0; l <= a; l++)l % 2 == 0 && c.line(l * n - 3 * cn - 0, 3 * -cn, l * n - 3 * cn - 0, 3 * cn); return c.pop(), c } function mPC(c, l, e, t) { c.clear(), c.fill(0, 255), c.stroke(0, 255), c.strokeWeight(.01 * dim), c.beginShape(); let a = 0; for (let e = 0; e <= dim; e += t)c.vertex(e, l[a]), a++; c.vertex(dim, e[e.length - 1]), a = e.length - 1; for (let l = dim; l >= 0; l -= t)c.vertex(l, e[a]), a--; return c.vertex(0, l[0]), c.endShape(), c } function mR(c, l) { c.clear(), c.fill(0, 255), c.stroke(0, 255), c.strokeWeight(.05 * dim); let e = dim / 3 * (l % 3) + dim / 3 / 2, t = dim / 3 * int(l / 3) + dim / 3 / 2 + dim / 37; c.textFont("sans-serif", .33 * dim), c.textAlign(CENTER, CENTER); let a = 0 == l || 8 == l ? "R" : 2 == l || 6 == l ? "Y" : 4 == l ? "" : "O"; return c.text(a, e, t), c } function mLi(c) { return c.clear(), c.fill(0, 255), c.stroke(0, 255), c.strokeWeight(.05 * dim), c.textFont("sans-serif", dim), c.textAlign(CENTER, CENTER), c.text(aL[li].ltr, dim / 2, dim / 2 + dim / 13), c } function c(c) { return color(c) } function rnd() { return s ^= s << 13, s ^= s >> 17, ((s ^= s << 5) < 0 ? 1 + ~s : s) % 1e3 / 1e3 }